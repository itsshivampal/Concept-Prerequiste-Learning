We begin by introducing a simple regression problem, which we shall use as a run-
ning example throughout this chapter to motivate a number of key concepts. Sup-
pose we observe a real-valued input variable x and we wish to use this observation to
predict the value of a real-valued target variable t. For the present purposes, it is in-
structive to consider an artificial example using synthetically generated data because
we then know the precise process that generated the data for comparison against any
learned model. The data for this example is generated from the function sin(2πx)
with random noise included in the target values, as described in detail in Appendix A.
Now suppose that we are given a training set comprising N observations of x,
written x ≡ (x1, . . . , xN )T, together with corresponding observations of the values
of t, denoted t ≡ (t1, . . . , tN )T. Figure 1.2 shows a plot of a training set comprising
N = 10 data points. The input data set x in Figure 1.2 was generated by choos-
ing values of xn, for n = 1, . . . , N, spaced uniformly in range [0, 1], and the target
data set t was obtained by first computing the corresponding values of the function
5
M
N
1.1. Example: Polynomial Curve Fitting
sin(2πx) and then adding a small level of random noise having a Gaussian distri-
bution (the Gaussian distribution is discussed in Section 1.2.4) to each such point in
order to obtain the corresponding value tn. By generating data in this way, we are
capturing a property of many real data sets, namely that they possess an underlying
regularity, which we wish to learn, but that individual observations are corrupted by
random noise. This noise might arise from intrinsically stochastic (i.e. random) pro-
cesses such as radioactive decay but more typically is due to there being sources of
variability that are themselves unobserved.
Our goal is to exploit this training set in order to make predictions of the value
t of the target variable for some new value
x of the input variable. As we shall see
later, this involves implicitly trying to discover the underlying function sin(2πx).
This is intrinsically a difficult problem as we have to generalize from a finite data
set. Furthermore the observed data are corrupted with noise, and so for a given
x
t. Probability theory, discussed
there is uncertainty as to the appropriate value for
in Section 1.2, provides a framework for expressing such uncertainty in a precise
and quantitative manner, and decision theory, discussed in Section 1.5, allows us to
exploit this probabilistic representation in order to make predictions that are optimal
according to appropriate criteria.
For the moment, however, we shall proceed rather informally and consider a
simple approach based on curve fitting. In particular, we shall fit the data using a
polynomial function of the form
y(x, w) = w0 + w1x + w2x2 + . . . + wM xM =
wjxj
(1.1)
j=0
where M is the order of the polynomial, and xj denotes x raised to the power of j.
The polynomial coefficients w0, . . . , wM are collectively denoted by the vector w.
Note that, although the polynomial function y(x, w) is a nonlinear function of x, it
is a linear function of the coefficients w. Functions, such as the polynomial, which
are linear in the unknown parameters have important properties and are called linear
models and will be discussed extensively in Chapters 3 and 4.
The values of the coefficients will be determined by fitting the polynomial to the
training data. This can be done by minimizing an error function that measures the
misfit between the function y(x, w), for any given value of w, and the training set
data points. One simple choice of error function, which is widely used, is given by
the sum of the squares of the errors between the predictions y(xn, w) for each data
point xn and the corresponding target values tn, so that we minimize
E(w) =
1
2
{y(xn, w) − tn}2
n=1
(1.2)
where the factor of 1/2 is included for later convenience. We shall discuss the mo-
tivation for this choice of error function later in this chapter. For the moment we
simply note that it is a nonnegative quantity that would be zero if, and only if, the
6
1. INTRODUCTION
Figure 1.3 The error
function (1.2) corre-
sponds to (one half of) the sum of
the squares of the displacements
(shown by the vertical green bars)
of each data point from the function
y(x, w).
t
tn
y(xn, w)
xn
x
function y(x, w) were to pass exactly through each training data point. The geomet-
rical interpretation of the sum-of-squares error function is illustrated in Figure 1.3.
We can solve the curve fitting problem by choosing the value of w for which
E(w) is as small as possible. Because the error function is a quadratic function of
the coefficients w, its derivatives with respect to the coefficients will be linear in the
elements of w, and so the minimization of the error function has a unique solution,
denoted by w, which can be found in closed form. The resulting polynomial is
given by the function y(x, w).
Exercise 1.1
There remains the problem of choosing the order M of the polynomial, and as
we shall see this will turn out to be an example of an important concept called model
comparison or model selection. In Figure 1.4, we show four examples of the results
of fitting polynomials having orders M = 0, 1, 3, and 9 to the data set shown in
Figure 1.2.
We notice that the constant (M = 0) and first order (M = 1) polynomials
give rather poor fits to the data and consequently rather poor representations of the
function sin(2πx). The third order (M = 3) polynomial seems to give the best fit
to the function sin(2πx) of the examples shown in Figure 1.4. When we go to a
much higher order polynomial (M = 9), we obtain an excellent fit to the training
data. In fact, the polynomial passes exactly through each data point and E(w) = 0.
However, the fitted curve oscillates wildly and gives a very poor representation of
the function sin(2πx). This latter behaviour is known as over-fitting.
As we have noted earlier, the goal is to achieve good generalization by making
accurate predictions for new data. We can obtain some quantitative insight into the
dependence of the generalization performance on M by considering a separate test
set comprising 100 data points generated using exactly the same procedure used
to generate the training set points but with new choices for the random noise values
included in the target values. For each choice of M, we can then evaluate the residual
value of E(w) given by (1.2) for the training data, and we can also evaluate E(w)
for the test data set. It is sometimes more convenient to use the root-mean-square
Figure 1.4 Plots of polynomials having various orders M, shown as red curves, fitted to the data set shown in
Figure 1.2.
(RMS) error defined by
ERMS =
2E(w)/N
(1.3)
in which the division by N allows us to compare different sizes of data sets on
an equal footing, and the square root ensures that ERMS is measured on the same
scale (and in the same units) as the target variable t. Graphs of the training and
test set RMS errors are shown, for various values of M, in Figure 1.5. The test
set error is a measure of how well we are doing in predicting the values of t for
new data observations of x. We note from Figure 1.5 that small values of M give
relatively large values of the test set error, and this can be attributed to the fact that
the corresponding polynomials are rather inflexible and are incapable of capturing
the oscillations in the function sin(2πx). Values of M in the range 3 � M � 8
give small values for the test set error, and these also give reasonable representations
of the generating function sin(2πx), as can be seen, for the case of M = 3, from
Figure 1.4.
1.1. Example: Polynomial Curve Fitting
7
t
1
0
−1
t
1
0
−1
0
0
M = 0
t
1
0
−1
1
x
0
M = 3
t
1
0
−1
1
x
0
M = 1
1
x
M = 9
1
x
8
1. INTRODUCTION
Figure 1.5 Graphs of
the root-mean-square
error, defined by (1.3), evaluated
on the training set and on an inde-
pendent test set for various values
of M.
Training
Test
1
S
M
R
E
0.5
0
0
3
M
6
9
For M = 9, the training set error goes to zero, as we might expect because
this polynomial contains 10 degrees of freedom corresponding to the 10 coefficients
w0, . . . , w9, and so can be tuned exactly to the 10 data points in the training set.
However, the test set error has become very large and, as we saw in Figure 1.4, the
corresponding function y(x, w) exhibits wild oscillations.
This may seem paradoxical because a polynomial of given order contains all
lower order polynomials as special cases. The M = 9 polynomial is therefore capa-
ble of generating results at least as good as the M = 3 polynomial. Furthermore, we
might suppose that the best predictor of new data would be the function sin(2πx)
from which the data was generated (and we shall see later that this is indeed the
case). We know that a power series expansion of the function sin(2πx) contains
terms of all orders, so we might expect that results should improve monotonically as
we increase M.
We can gain some insight into the problem by examining the values of the co-
efficients w obtained from polynomials of various order, as shown in Table 1.1.
We see that, as M increases, the magnitude of the coefficients typically gets larger.
In particular for the M = 9 polynomial, the coefficients have become finely tuned
to the data by developing large positive and negative values so that the correspond-
Table 1.1 Table of the coefficients w for
polynomials of various order.
Observe how the typical mag-
nitude of
the coefficients in-
creases dramatically as the or-
der of the polynomial increases.
w
0
w
1
w
2
w
3
w
4
w
5
w
6
w
7
w
8
w
9
0.19
M = 0 M = 1 M = 6
0.31
7.99
-25.43
17.37
0.82
-1.27
M = 9
0.35
232.37
-5321.83
48568.31
-231639.30
640042.26
-1061800.52
1042400.18
-557682.99
125201.43
t
1
0
−1
0
1.1. Example: Polynomial Curve Fitting
9
N = 100
N = 15
t
1
0
−1
1
x
0
1
x
Figure 1.6 Plots of the solutions obtained by minimizing the sum-of-squares error function using the M = 9
polynomial for N = 15 data points (left plot) and N = 100 data points (right plot). We see that increasing the
size of the data set reduces the over-fitting problem.
ing polynomial function matches each of the data points exactly, but between data
points (particularly near the ends of the range) the function exhibits the large oscilla-
tions observed in Figure 1.4. Intuitively, what is happening is that the more flexible
polynomials with larger values of M are becoming increasingly tuned to the random
noise on the target values.
It is also interesting to examine the behaviour of a given model as the size of the
data set is varied, as shown in Figure 1.6. We see that, for a given model complexity,
the over-fitting problem become less severe as the size of the data set increases.
Another way to say this is that the larger the data set, the more complex (in other
words more flexible) the model that we can afford to fit to the data. One rough
heuristic that is sometimes advocated is that the number of data points should be
no less than some multiple (say 5 or 10) of the number of adaptive parameters in
the model. However, as we shall see in Chapter 3, the number of parameters is not
necessarily the most appropriate measure of model complexity.
Also, there is something rather unsatisfying about having to limit the number of
parameters in a model according to the size of the available training set. It would
seem more reasonable to choose the complexity of the model according to the com-
plexity of the problem being solved. We shall see that the least squares approach
to finding the model parameters represents a specific case of maximum likelihood
(discussed in Section 1.2.5), and that the over-fitting problem can be understood as
a general property of maximum likelihood. By adopting a Bayesian approach, the
over-fitting problem can be avoided. We shall see that there is no difficulty from
a Bayesian perspective in employing models for which the number of parameters
greatly exceeds the number of data points. Indeed, in a Bayesian model the effective
number of parameters adapts automatically to the size of the data set.
For the moment, however, it is instructive to continue with the current approach
and to consider how in practice we can apply it to data sets of limited size where we
Section 3.4
t
N
1
0
−1
may wish to use relatively complex and flexible models. One technique that is often
used to control the over-fitting phenomenon in such cases is that of regularization,
which involves adding a penalty term to the error function (1.2) in order to discourage
the coefficients from reaching large values. The simplest such penalty term takes the
form of a sum of squares of all of the coefficients, leading to a modified error function
of the form
E(w) =
1
2
{y(xn, w) − tn}2 + λ
2w2
(1.4)
n=1
1 + . . . + w2
0 + w2
where w2 ≡ wTw = w2
M , and the coefficient λ governs the rel-
ative importance of the regularization term compared with the sum-of-squares error
term. Note that often the coefficient w0 is omitted from the regularizer because its
inclusion causes the results to depend on the choice of origin for the target variable
(Hastie et al., 2001), or it may be included but with its own regularization coefficient
(we shall discuss this topic in more detail in Section 5.5.1). Again, the error function
in (1.4) can be minimized exactly in closed form. Techniques such as this are known
in the statistics literature as shrinkage methods because they reduce the value of the
coefficients. The particular case of a quadratic regularizer is called ridge regres-
sion (Hoerl and Kennard, 1970). In the context of neural networks, this approach is
known as weight decay.
Figure 1.7 shows the results of fitting the polynomial of order M = 9 to the
same data set as before but now using the regularized error function given by (1.4).
We see that, for a value of ln λ = −18, the over-fitting has been suppressed and we
now obtain a much closer representation of the underlying function sin(2πx). If,
however, we use too large a value for λ then we again obtain a poor fit, as shown in
Figure 1.7 for ln λ = 0. The corresponding coefficients from the fitted polynomials
are given in Table 1.2, showing that regularization has the desired effect of reducing
Exercise 1.2
10
1. INTRODUCTION
t
1
0
−1
0
ln λ = −18
1
x
ln λ = 0
0
1
x
Figure 1.7 Plots of M = 9 polynomials fitted to the data set shown in Figure 1.2 using the regularized error
function (1.4) for two values of the regularization parameter λ corresponding to ln λ = −18 and ln λ = 0. The
case of no regularizer, i.e., λ = 0, corresponding to ln λ = −∞, is shown at the bottom right of Figure 1.4.
1.1. Example: Polynomial Curve Fitting
11
Table 1.2 Table of the coefficients w for M =
9 polynomials with various values for
the regularization parameter λ. Note
that ln λ = −∞ corresponds to a
model with no regularization, i.e., to
the graph at the bottom right in Fig-
ure 1.4. We see that, as the value of
λ increases, the typical magnitude of
the coefficients gets smaller.
ln λ = −∞ ln λ = −18
0.35
4.74
-0.77
-31.97
-3.89
55.28
41.32
-45.95
-91.53
72.68
0.35
232.37
-5321.83
48568.31
-231639.30
640042.26
-1061800.52
1042400.18
-557682.99
125201.43
ln λ = 0
0.13
-0.05
-0.06
-0.05
-0.03
-0.02
-0.01
-0.00
0.00
0.01
w
0
w
1
w
2
w
3
w
4
w
5
w
6
w
7
w
8
w
9
the magnitude of the coefficients.
The impact of the regularization term on the generalization error can be seen by
plotting the value of the RMS error (1.3) for both training and test sets against ln λ,
as shown in Figure 1.8. We see that in effect λ now controls the effective complexity
of the model and hence determines the degree of over-fitting.
The issue of model complexity is an important one and will be discussed at
length in Section 1.3. Here we simply note that, if we were trying to solve a practical
application using this approach of minimizing an error function, we would have to
find a way to determine a suitable value for the model complexity. The results above
suggest a simple way of achieving this, namely by taking the available data and
partitioning it into a training set, used to determine the coefficients w, and a separate
validation set, also called a hold-out set, used to optimize the model complexity
(either M or λ).
In many cases, however, this will prove to be too wasteful of
valuable training data, and we have to seek more sophisticated approaches.
So far our discussion of polynomial curve fitting has appealed largely to in-
tuition. We now seek a more principled approach to solving problems in pattern
recognition by turning to a discussion of probability theory. As well as providing the
foundation for nearly all of the subsequent developments in this book, it will also
Section 1.3
Figure 1.8 Graph of the root-mean-square er-
ror (1.3) versus ln λ for the M = 9
polynomial.
1
Training
Test
S
M
R
E
0.5
0
−35
−30
−25
ln λ
−20
12
1. INTRODUCTION
give us some important insights into the concepts we have introduced in the con-
text of polynomial curve fitting and will allow us to extend these to more complex
situations.
